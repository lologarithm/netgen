// Code generated by netgen tool on Oct 4 2018 01:01 MDT. DO NOT EDIT
package main

import (
	"github.com/lologarithm/netgen/lib/ngen"
)


const (
	UnknownMsgType ngen.MessageType = iota
	AckMsgType
	BenchyMsgType
	FeaturesOneMsgType
	FeaturesMsgType
)

// ParseNetMessage accepts input of raw bytes from a NetMessage. Parses and returns a Net message.
func ParseNetMessage(packet ngen.Packet, content *ngen.Buffer) ngen.Net {
	switch packet.Header.MsgType {
	case BenchyMsgType:
		msg := BenchyDeserialize(content)
		return &msg
	case FeaturesOneMsgType:
		msg := FeaturesOneDeserialize(content)
		return &msg
	case FeaturesMsgType:
		msg := FeaturesDeserialize(content)
		return &msg
	default:
		return nil
	}
}


func BenchyDeserialize(buffer *ngen.Buffer) (m Benchy) {
	m.Name, _ = buffer.ReadString()
	m.BirthDay, _ = buffer.ReadInt64()
	m.Phone, _ = buffer.ReadString()
	m.Siblings, _ = buffer.ReadInt32()
	m.Spouse, _ = buffer.ReadByte()
	m.Money, _ = buffer.ReadFloat64()
	return m
}

func FeaturesOneDeserialize(buffer *ngen.Buffer) (m FeaturesOne) {
	if v, _ := buffer.ReadByte(); v == 1 {
		var subDynd = FeaturesOneDeserialize(buffer)
		m.Dynd = &subDynd
	}
	m.V, _ = buffer.ReadInt()
	return m
}

func FeaturesDeserialize(buffer *ngen.Buffer) (m Features) {
	if v, _ := buffer.ReadByte(); v == 1 {
		iType0, _ := buffer.ReadUint16()
		p := ngen.Packet{Header: ngen.Header{MsgType: ngen.MessageType(	iType0)}}
		m.Dynd = ParseNetMessage(p, buffer).(MyInterface)
	}
	m.Bin, _ = buffer.ReadByteSlice()
	l2_1, _ := buffer.ReadUint32()
	m.OtherFeatures = make([]*Features, l2_1)
	for i := uint32(0); i < l2_1; i++ {
		if v, _ := buffer.ReadByte(); v == 1 {
			var subi = FeaturesDeserialize(buffer)
			m.OtherFeatures[i] = &subi
		}
	}
	m.DatBenchy = BenchyDeserialize(buffer)
	tmpEnumyV, _ := buffer.ReadUint32()
	m.EnumyV = Enumy(tmpEnumyV)
	return m
}
