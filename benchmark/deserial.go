// GENERATED BY netgen tool on Oct 1 2018 22:45 MDT
package main

import (
	"github.com/lologarithm/netgen/lib/ngen"
)

const (
	UnknownMsgType ngen.MessageType = iota
	AckMsgType
	BenchyMsgType
	FeaturesMsgType
)

// ParseNetMessage accepts input of raw bytes from a NetMessage. Parses and returns a Net message.
func ParseNetMessage(packet ngen.Packet, content *ngen.Buffer) ngen.Net {
	switch packet.Header.MsgType {
	case BenchyMsgType:
		msg := BenchyDeserialize(content)
		return &msg
	case FeaturesMsgType:
		msg := FeaturesDeserialize(content)
		return &msg
	default:
		return nil
	}
}

func BenchyDeserialize(buffer *ngen.Buffer) (m Benchy) {
	m.Name, _ = buffer.ReadString()
	m.BirthDay, _ = buffer.ReadInt64()
	m.Phone, _ = buffer.ReadString()
	m.Siblings, _ = buffer.ReadInt32()
	m.Spouse, _ = buffer.ReadByte()
	m.Money, _ = buffer.ReadFloat64()
	return m
}

func FeaturesDeserialize(buffer *ngen.Buffer) (m Features) {
	iType0, _ := buffer.ReadUint16()
	p := ngen.Packet{Header: ngen.Header{MsgType: ngen.MessageType(iType0)}}
	m.Dynd = ParseNetMessage(p, buffer).(MyInterface)
	m.Bin, _ = buffer.ReadByteSlice()
	l2_1, _ := buffer.ReadUint32()
	m.OtherFeatures = make([]*Features, l2_1)
	for i := uint32(0); i < l2_1; i++ {
		var subi = FeaturesDeserialize(buffer)
		m.OtherFeatures[i] = &subi
	}
	m.DatBenchy = BenchyDeserialize(buffer)
	tmpEnumyV, _ := buffer.ReadUint32()
	m.EnumyV = Enumy(tmpEnumyV)
	return m
}
